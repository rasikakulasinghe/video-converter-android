/**
 * @fileoverview Contract tests for FileManagerService interface
 * Validates that implementations conform to the service contract
 * 
 * Constitutional Requirements:
 * - TDD Approach: Contract tests validate service interfaces
 * - TypeScript Excellence: Strict interface compliance testing
 * - Test Coverage: Service contract validation
 */

import { jest } from '@jest/globals';

// Import service interface and implementation
import { FileManagerService, StorageLocation, PermissionType } from '../../src/services/FileManagerService';
import { ReactNativeFileManager } from '../../src/services/implementations/ReactNativeFileManager';

// Import types
import type { VideoFile } from '../../src/types/models';

// Mock React Native FS
jest.mock('react-native-fs', () => ({
  DocumentDirectoryPath: '/mock/documents',
  CachesDirectoryPath: '/mock/caches',
  ExternalDirectoryPath: '/mock/external',
  exists: jest.fn(() => Promise.resolve(true)),
  stat: jest.fn(() => Promise.resolve({
    size: 1000000,
    isFile: () => true,
    isDirectory: () => false,
    mtime: new Date(),
    ctime: new Date(),
  })),
  readDir: jest.fn(() => Promise.resolve([])),
  copyFile: jest.fn(() => Promise.resolve()),
  moveFile: jest.fn(() => Promise.resolve()),
  unlink: jest.fn(() => Promise.resolve()),
  mkdir: jest.fn(() => Promise.resolve()),
  writeFile: jest.fn(() => Promise.resolve()),
  readFile: jest.fn(() => Promise.resolve('mock content')),
}));

describe('FileManagerService Contract Tests', () => {
  let fileManager: FileManagerService;

  beforeEach(() => {
    fileManager = new ReactNativeFileManager();
    jest.clearAllMocks();
  });

  describe('Interface Compliance', () => {
    it('should implement FileManagerService interface', () => {
      expect(fileManager).toBeInstanceOf(ReactNativeFileManager);
      expect(fileManager).toBeDefined();
    });

    it('should have all required file operation methods', () => {
      expect(typeof fileManager.getFileInfo).toBe('function');
      expect(typeof fileManager.exists).toBe('function');
      expect(typeof fileManager.createFile).toBe('function');
      expect(typeof fileManager.deleteFile).toBe('function');
      expect(typeof fileManager.moveFile).toBe('function');
      expect(typeof fileManager.copyFile).toBe('function');
      expect(typeof fileManager.renameFile).toBe('function');
    });

    it('should have all required directory operation methods', () => {
      expect(typeof fileManager.getDirectoryInfo).toBe('function');
      expect(typeof fileManager.createDirectory).toBe('function');
      expect(typeof fileManager.deleteDirectory).toBe('function');
      expect(typeof fileManager.listDirectory).toBe('function');
    });

    it('should have all required storage operation methods', () => {
      expect(typeof fileManager.getStorageInfo).toBe('function');
      expect(typeof fileManager.getAvailableSpace).toBe('function');
      expect(typeof fileManager.getUsedSpace).toBe('function');
      expect(typeof fileManager.getTotalSpace).toBe('function');
      expect(typeof fileManager.cleanupTempFiles).toBe('function');
    });

    it('should have all required permission operation methods', () => {
      expect(typeof fileManager.requestPermission).toBe('function');
      expect(typeof fileManager.checkPermission).toBe('function');
      expect(typeof fileManager.hasPermission).toBe('function');
    });

    it('should have all required file validation methods', () => {
      expect(typeof fileManager.validateVideoFile).toBe('function');
      expect(typeof fileManager.validateFilePath).toBe('function');
      expect(typeof fileManager.validateFileName).toBe('function');
    });

    it('should have all required utility methods', () => {
      expect(typeof fileManager.generateThumbnail).toBe('function');
      expect(typeof fileManager.getFileMimeType).toBe('function');
      expect(typeof fileManager.getFileExtension).toBe('function');
      expect(typeof fileManager.sanitizeFileName).toBe('function');
      expect(typeof fileManager.generateUniqueFileName).toBe('function');
    });
  });

  describe('File Operation Contracts', () => {
    const testFilePath = '/mock/test.mp4';

    it('should return file existence status', async () => {
      const exists = await fileManager.exists(testFilePath);
      expect(typeof exists).toBe('boolean');
    });

    it('should get file info with required properties', async () => {
      const fileInfo = await fileManager.getFileInfo(testFilePath);
      
      expect(fileInfo).toHaveProperty('name');
      expect(fileInfo).toHaveProperty('path');
      expect(fileInfo).toHaveProperty('size');
      expect(fileInfo).toHaveProperty('mimeType');
      expect(fileInfo).toHaveProperty('isDirectory');
      expect(fileInfo).toHaveProperty('isFile');
      expect(fileInfo).toHaveProperty('createdAt');
      expect(fileInfo).toHaveProperty('lastModified');
    });

    it('should handle file operations', async () => {
      const sourceFile = '/mock/source.mp4';
      const targetFile = '/mock/target.mp4';
      
      // Test copy operation
      await expect(fileManager.copyFile(sourceFile, targetFile)).resolves.toBeUndefined();
      
      // Test move operation
      await expect(fileManager.moveFile(sourceFile, targetFile)).resolves.toBeUndefined();
      
      // Test delete operation
      await expect(fileManager.deleteFile(testFilePath)).resolves.toBeUndefined();
    });
  });

  describe('Directory Operation Contracts', () => {
    const testDirPath = '/mock/testdir';

    it('should handle directory creation and deletion', async () => {
      await expect(fileManager.createDirectory(testDirPath)).resolves.toBeUndefined();
      await expect(fileManager.deleteDirectory(testDirPath)).resolves.toBeUndefined();
    });

    it('should list directory contents', async () => {
      const files = await fileManager.listDirectory(testDirPath);
      expect(Array.isArray(files)).toBe(true);
    });
  });

  describe('Storage Operation Contracts', () => {
    it('should get storage information', async () => {
      const storageInfo = await fileManager.getStorageInfo(StorageLocation.INTERNAL);
      
      expect(storageInfo).toHaveProperty('totalSpace');
      expect(storageInfo).toHaveProperty('availableSpace');
      expect(storageInfo).toHaveProperty('usedSpace');
      expect(typeof storageInfo.totalSpace).toBe('number');
      expect(typeof storageInfo.availableSpace).toBe('number');
      expect(typeof storageInfo.usedSpace).toBe('number');
    });

    it('should get space measurements', async () => {
      const totalSpace = await fileManager.getTotalSpace();
      const availableSpace = await fileManager.getAvailableSpace();
      const usedSpace = await fileManager.getUsedSpace();
      
      expect(typeof totalSpace).toBe('number');
      expect(typeof availableSpace).toBe('number');
      expect(typeof usedSpace).toBe('number');
    });

    it('should cleanup temp files', async () => {
      const cleanedBytes = await fileManager.cleanupTempFiles();
      expect(typeof cleanedBytes).toBe('number');
    });
  });

  describe('Permission Operation Contracts', () => {
    it('should check permissions', async () => {
      const hasPermission = await fileManager.hasPermission(PermissionType.STORAGE);
      expect(typeof hasPermission).toBe('boolean');
    });

    it('should handle permission requests', async () => {
      const permissionResult = await fileManager.requestPermission(PermissionType.STORAGE);
      expect(permissionResult).toHaveProperty('status');
      expect(permissionResult).toHaveProperty('canAskAgain');
      expect(typeof permissionResult.canAskAgain).toBe('boolean');
    });
  });

  describe('Validation Contracts', () => {
    it('should validate file paths', () => {
      const isValid = fileManager.validateFilePath('/valid/path.mp4');
      expect(typeof isValid).toBe('boolean');
    });

    it('should validate file names', () => {
      const isValid = fileManager.validateFileName('valid_file.mp4');
      expect(typeof isValid).toBe('boolean');
    });

    it('should validate video files', async () => {
      const result = await fileManager.validateVideoFile('/mock/video.mp4');
      expect(result).toHaveProperty('isValid');
      expect(typeof result.isValid).toBe('boolean');
    });
  });

  describe('Utility Operation Contracts', () => {
    it('should get file MIME type', async () => {
      const mimeType = await fileManager.getFileMimeType('/mock/test.mp4');
      expect(typeof mimeType).toBe('string');
    });

    it('should get file extension', () => {
      const extension = fileManager.getFileExtension('test.mp4');
      expect(typeof extension).toBe('string');
      expect(extension).toBe('.mp4');
    });

    it('should sanitize file names', () => {
      const sanitized = fileManager.sanitizeFileName('invalid<>file|name.mp4');
      expect(typeof sanitized).toBe('string');
      expect(sanitized).not.toContain('<');
      expect(sanitized).not.toContain('>');
      expect(sanitized).not.toContain('|');
    });

    it('should generate unique file names', async () => {
      const uniqueName = await fileManager.generateUniqueFileName('/mock/', 'test.mp4');
      expect(typeof uniqueName).toBe('string');
      expect(uniqueName).toContain('test');
      expect(uniqueName).toContain('.mp4');
    });
  });

  describe('Error Handling Contracts', () => {
    it('should handle file not found errors gracefully', async () => {
      const RNFS = require('react-native-fs');
      RNFS.exists.mockResolvedValueOnce(false);
      
      await expect(fileManager.getFileInfo('/nonexistent/file.mp4'))
        .rejects.toThrow();
    });

    it('should handle permission denied errors', async () => {
      const RNFS = require('react-native-fs');
      RNFS.copyFile.mockRejectedValueOnce(new Error('Permission denied'));
      
      await expect(
        fileManager.copyFile('/mock/source.mp4', '/restricted/target.mp4')
      ).rejects.toThrow('Permission denied');
    });
  });

  describe('Performance Contracts', () => {
    it('should handle large file operations efficiently', async () => {
      const largePath = '/mock/large-video.mp4';
      const RNFS = require('react-native-fs');
      
      RNFS.stat.mockResolvedValueOnce({
        size: 1073741824, // 1GB
        isFile: () => true,
        isDirectory: () => false,
        mtime: new Date(),
        ctime: new Date(),
      });

      const startTime = Date.now();
      const fileInfo = await fileManager.getFileInfo(largePath);
      const endTime = Date.now();

      expect(fileInfo.size).toBe(1073741824);
      expect(endTime - startTime).toBeLessThan(1000); // Less than 1 second
    });

    it('should handle cache cleanup efficiently', async () => {
      const startTime = Date.now();
      await fileManager.cleanupTempFiles();
      const endTime = Date.now();

      expect(endTime - startTime).toBeLessThan(5000); // Less than 5 seconds
    });
  });
});